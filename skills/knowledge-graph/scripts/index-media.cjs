#!/usr/bin/env node
/**
 * Auto-index inbound media files
 * 
 * Watches ~/.openclaw/media/inbound/ for new files,
 * copies them to clients/{name}/files/ with descriptive names,
 * and maintains an INDEX.md for easy retrieval.
 * 
 * Usage:
 *   node index-media.cjs                    # process new files
 *   node index-media.cjs --reindex          # reindex all files
 * 
 * Designed to run on cron (every 10-30 min) or in HEARTBEAT.md
 */

const fs = require('fs');
const path = require('path');

// --- Config ---
const WORKSPACE = process.env.WORKSPACE || path.resolve(__dirname, '../../..');
const MEDIA_DIR = path.join(process.env.HOME, '.openclaw/media/inbound');
const STATE_FILE = path.join(WORKSPACE, 'memory/.media-index-state.json');
const DEFAULT_CLIENT_DIR = path.join(WORKSPACE, 'clients/_unassigned/files');
const REINDEX = process.argv.includes('--reindex');

// --- Load conversation context to match files to clients ---
function findClientForFile(filename, timestamp) {
  // Try to match file to a client by checking recent daily notes and conversation logs
  const clientsDir = path.join(WORKSPACE, 'clients');
  if (!fs.existsSync(clientsDir)) return null;
  
  const clients = fs.readdirSync(clientsDir).filter(d => 
    d !== '_unassigned' && fs.statSync(path.join(clientsDir, d)).isDirectory()
  );
  
  // Check recent session transcripts for the filename
  try {
    const agentsDir = path.join(process.env.HOME, '.openclaw/agents/main/sessions');
    if (fs.existsSync(agentsDir)) {
      const sessions = fs.readdirSync(agentsDir)
        .filter(f => f.endsWith('.jsonl'))
        .sort().reverse().slice(0, 5); // last 5 sessions
      
      for (const session of sessions) {
        const content = fs.readFileSync(path.join(agentsDir, session), 'utf-8');
        if (content.includes(filename)) {
          // Check which client name appears near the file reference
          for (const client of clients) {
            if (content.toLowerCase().includes(client.toLowerCase())) {
              return client;
            }
          }
        }
      }
    }
  } catch {}
  
  return null;
}

// --- Generate descriptive filename ---
function makeDescriptiveName(originalName, timestamp) {
  const ext = path.extname(originalName);
  const date = new Date(timestamp).toISOString().slice(0, 10);
  // Clean up OpenClaw's naming: file_473---8d9408b8-7e4e-4bab.jpg â†’ just use date + counter
  const clean = originalName
    .replace(/^file_\d+---/, '')
    .replace(/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}/, '')
    .replace(/^[-_]+|[-_]+$/g, '');
  
  if (clean && clean !== ext) {
    return `${date}_${clean}`;
  }
  return `${date}_attachment${ext}`;
}

// --- Load state ---
function loadState() {
  try {
    return JSON.parse(fs.readFileSync(STATE_FILE, 'utf-8'));
  } catch {
    return { indexed: {} };
  }
}

function saveState(state) {
  const dir = path.dirname(STATE_FILE);
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
  fs.writeFileSync(STATE_FILE, JSON.stringify(state, null, 2));
}

// --- Update INDEX.md ---
function updateIndex(clientDir, entry) {
  const indexPath = path.join(clientDir, 'INDEX.md');
  let content = '';
  if (fs.existsSync(indexPath)) {
    content = fs.readFileSync(indexPath, 'utf-8');
  } else {
    content = '# File Index\n\nAuto-generated by index-media.cjs. Files received from client.\n\n| Date | File | Type | Original | Size |\n|------|------|------|----------|------|\n';
  }
  
  content += `| ${entry.date} | [${entry.name}](${entry.name}) | ${entry.type} | ${entry.original} | ${entry.size} |\n`;
  fs.writeFileSync(indexPath, content);
}

// --- Main ---
function main() {
  if (!fs.existsSync(MEDIA_DIR)) {
    console.log('No media directory found:', MEDIA_DIR);
    return;
  }
  
  const state = REINDEX ? { indexed: {} } : loadState();
  const files = fs.readdirSync(MEDIA_DIR).filter(f => !f.startsWith('.'));
  
  let indexed = 0;
  let skipped = 0;
  
  for (const file of files) {
    const fullPath = path.join(MEDIA_DIR, file);
    const stat = fs.statSync(fullPath);
    
    // Skip if already indexed
    if (state.indexed[file] && !REINDEX) {
      skipped++;
      continue;
    }
    
    // Skip directories
    if (stat.isDirectory()) continue;
    
    const timestamp = stat.mtime;
    const client = findClientForFile(file, timestamp);
    const clientName = client || '_unassigned';
    const clientFilesDir = path.join(WORKSPACE, 'clients', clientName, 'files');
    
    // Create directory
    if (!fs.existsSync(clientFilesDir)) fs.mkdirSync(clientFilesDir, { recursive: true });
    
    // Generate descriptive name
    const newName = makeDescriptiveName(file, timestamp);
    const destPath = path.join(clientFilesDir, newName);
    
    // Copy file (don't move â€” OpenClaw may still reference original)
    if (!fs.existsSync(destPath)) {
      fs.copyFileSync(fullPath, destPath);
    }
    
    // Determine type
    const ext = path.extname(file).toLowerCase();
    const typeMap = {
      '.jpg': 'image', '.jpeg': 'image', '.png': 'image', '.gif': 'image', '.webp': 'image',
      '.pdf': 'document', '.doc': 'document', '.docx': 'document',
      '.xls': 'spreadsheet', '.xlsx': 'spreadsheet', '.csv': 'spreadsheet',
      '.mp4': 'video', '.mov': 'video', '.avi': 'video',
      '.mp3': 'audio', '.ogg': 'audio', '.wav': 'audio', '.m4a': 'audio',
    };
    const type = typeMap[ext] || 'file';
    
    // Update index
    const sizeKB = Math.round(stat.size / 1024);
    updateIndex(clientFilesDir, {
      date: timestamp.toISOString().slice(0, 10),
      name: newName,
      type,
      original: file,
      size: sizeKB > 1024 ? `${(sizeKB / 1024).toFixed(1)}MB` : `${sizeKB}KB`,
    });
    
    // Track state
    state.indexed[file] = {
      client: clientName,
      newName,
      indexedAt: new Date().toISOString(),
    };
    
    indexed++;
    console.log(`ðŸ“Ž ${file} â†’ clients/${clientName}/files/${newName}`);
  }
  
  saveState(state);
  console.log(`\nâœ… Indexed: ${indexed} new, ${skipped} already indexed, ${files.length} total files`);
}

main();
